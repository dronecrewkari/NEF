%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EXAMPLE 12
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Estimation of state of linear Gaussian system 
% with control input generated by LQG controller
% x(k+1) = F*x(k) + G*u(k) + w(k)
% z(k) = H*x(k) + v(k)
% nx = 2, nz = 2
% p(w(k)) = N{w(k):0,Q}
% p(v(k)) = N{w(k):0,R}
% p(x(0)) = N{x(0):m0,P0}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% estimators:
% KALMAN - Kalman filter
% controller:
% Asymptotic LQG

% NEF version 1.4.1
% Copyright (c) 2006 - 2017 NFT developement team,
%              Identification and Decision Making Research Group, Department of Cybernetics,
%              University of West Bohemia

clear all
fprintf('##################################################\n')
fprintf('# EXAMPLE 12 (Use ot NEF with controller\n')
fprintf('##################################################\n')

disp('Creating classes for structural description of the system...')
% STRUCTURAL DESCRIPTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% function f in state equation (with 1st derivatives)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
F = [0.9 0.01;0.01 0.9];
G = 1*eye(2);
f = nefLinFunction(F,G,1*eye(2));
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% function h in measurement equation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
H = [5 0;0 1];
h = nefLinFunction(H,[],eye(2));
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% state noise
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Q = 0.05*[1 2;2 5]; %eye(2);
w = nefGaussianRV([0;0],Q);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% measurement noise
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
R = 0.01*[3 1;1 4];
v = nefGaussianRV([0;0],R);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% initial condiditon
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
x0 = nefGaussianRV([1;10],1e-1*eye(2));
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% creating system and simulating its trajectory
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
system=nefEqSystem(f,h,w,v,x0);


disp('Filter setup ...')
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% setting up the Kalman filter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
KALMAN = nefKalman(system);
% note that the estimator uses in this case prior
% equal to the initial condition.

disp('Executing the control loop ...')
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The control loop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% set quadratic criterion parameters
Qc = eye(2);
Rc = eye(2)*0.01;

% Get the solution of algebraic Riccati equation, note that this is used
% only for simplicity (it corresponds only to infinite horizon control
% problem). Properly it would be necessary to solve recursive Riccati
% equation and obrain all the P_k matrices.
P  = dare(F,G,Qc,Rc); 

% set lenght of the control horizon
controlHorizon = 100;

% Initialize storage for measurements, state vectors
% and control
z = zeros(2,controlHorizon);
x = zeros(2,controlHorizon);
u = zeros(2,controlHorizon);

% initialize the system trajectory and corresponding measurement
[z(:,1),x(:,1),system] = simulate(system,1,0);

predPDF.RV=x0;

for timeStep = 1:controlHorizon
    
    % determine current filtering pdf
    filtPDF = measurementUpdate(KALMAN,predPDF,[],z(:,timeStep),timeStep);
    
    % determine control
    u(:,timeStep) = -(Rc+G'*P*G)\G'*P*F*evalMean(filtPDF.RV);
    
    % determine one step ahead predictive pdf
    predPDF = timeUpdate(KALMAN,filtPDF,u(:,timeStep),timeStep);
    
    % simulate one step of the system trajectory
    [z(:,timeStep+1),x(:,timeStep+1),system] = simulate(system,1,u(:,timeStep));
end;

figure
subplot(2,1,1);
plot(z(1,:))
ylabel('z_1');
xlabel('time');
subplot(2,1,2);
plot(z(2,:))
ylabel('z_2');
xlabel('time');

